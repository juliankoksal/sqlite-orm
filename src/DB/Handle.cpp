//
//  Handle.cpp
//  SQLite3 Data Access Layer
//
//  Created by Julian Koksal on 2023-02-12.
//

#include "Handle.hpp"

using namespace DB;

Handle::Handle(const std::string fileName)
{
    openDB(fileName);
}

Handle::~Handle()
{
    closeDB();
}

std::int64_t Handle::insert(const Object& dbObject) const
{
    std::string query = "INSERT INTO " + dbObject.table() + " VALUES (";
    
    const std::size_t columnCount = dbObject.columns().size();
    for (std::size_t i = 0; i < columnCount; i++)
    {
        query += "?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += ");";
    
    sqlite3_stmt* statement = prepareStatement(query);
    
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, dbObject, dbObject.columns(), index, true);
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error inserting to '" + dbObject.table() + "'.");
    
    if (dbObject.isAutoGeneratedKey())
    {
        return sqlite3_last_insert_rowid(db);
    }
    return 0;
}

void Handle::update(const Object& dbObject) const
{
    const std::set<std::string>& keys = dbObject.keys();
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DB::Handle::update(). '"
                                 + dbObject.table() + "' has no keys.");
    }
    
    const std::vector<std::string>& allColumns = dbObject.columns();
    
    std::vector<std::string> columnsToBind;
    std::vector<std::string> keysToBind;
    for (auto it = allColumns.cbegin(); it != allColumns.cend(); ++it)
    {
        if (keys.count(*it))
        {
            keysToBind.push_back(*it);
        }
        else
        {
            columnsToBind.push_back(*it);
        }
    }
    
    std::string query;
    query  = "UPDATE " + dbObject.table() + " SET ";
    for (auto it = columnsToBind.cbegin(); it != columnsToBind.cend(); ++it)
    {
        query += *it + " = ?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += generateWhereClauseFromKeys(keysToBind);
    query  = query.substr(0, query.size() - 5);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query);
    
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, dbObject, columnsToBind, index);
    bindStatementColumns(statement, dbObject, keysToBind, index);
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error updating '" + dbObject.table() + "'.");
}

void Handle::updateWhere(const Object& dbObject,
                         const std::vector<Condition>& conditions,
                         const std::set<std::string>& columns) const
{
    const std::set<std::string>& keys = dbObject.keys();
    const std::vector<std::string>& allColumns = dbObject.columns();
    
    std::vector<std::string> columnsToBind;
    for (auto it = allColumns.cbegin(); it != allColumns.cend(); ++it)
    {
        if (keys.count(*it))
        {
            continue;
        }
        if (columns.empty() || columns.count(*it))
        {
            columnsToBind.push_back(*it);;
        }
    }
    
    std::string query = "UPDATE " + dbObject.table() + " SET ";
    for (auto it = columnsToBind.cbegin(); it != columnsToBind.cend(); ++it)
    {
        query += *it + " = ?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += generateWhereClauseFromConditions(conditions);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query);
    
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, dbObject, columnsToBind, index);
    bindStatementConditions(statement, conditions, index);
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error updating '" + dbObject.table() + "'.");
}

void Handle::destroy(const Object& dbObject) const
{
    const std::set<std::string>& keys = dbObject.keys();
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DB::Handle::destroy(). '"
                                 + dbObject.table() + "' has no keys.");
    }
    
    const std::vector<std::string>& allColumns = dbObject.columns();

    std::vector<std::string> keysToBind;
    for (auto it = allColumns.cbegin(); it != allColumns.cend(); ++it)
    {
        if (keys.count(*it))
        {
            keysToBind.push_back(*it);
        }
    }
    
    std::string query;
    query  = "DELETE FROM " + dbObject.table();
    query += generateWhereClauseFromKeys(keysToBind);
    query  = query.substr(0, query.size() - 5);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query);
    
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, dbObject, keysToBind, index);
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error deleting from '" + dbObject.table() + "'.");
}

void Handle::destroyWhere(const Object& dbObject,
                          const std::vector<Condition>& conditions) const
{
    std::string query = "DELETE FROM " + dbObject.table();
    query += generateWhereClauseFromConditions(conditions);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query);
    
    int index = 1;
    bindStatementConditions(statement, conditions, index);
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error deleting from '" + dbObject.table() + "'.");
}

std::vector<Object*> Handle::selectHelper(const Object& dbObject,
                                          const std::vector<Condition>& conditions,
                                          const std::string &orderBy,
                                          const std::set<std::string>& columns) const
{
    const std::vector<std::string>& allColumns = dbObject.columns();
    
    std::vector<const std::string> columnsToSelect;
    for (auto it = allColumns.cbegin(); it != allColumns.cend(); ++it)
    {
        if (columns.empty() || columns.count(*it))
        {
            columnsToSelect.push_back(*it);
        }
    }
    
    std::string query = "SELECT ";
    for (auto it = columnsToSelect.cbegin(); it != columnsToSelect.cend(); ++it)
    {
        query += *it + ",";
    }
    query = query.substr(0, query.size() - 1);
    query += " FROM " + dbObject.table();
    query += generateWhereClauseFromConditions(conditions);
    if (!orderBy.empty())
    {
        query += " ORDER BY " + orderBy;
    }
    query += ";";
    
    sqlite3_stmt* statement = prepareStatement(query);
    
    int index = 1;
    bindStatementConditions(statement, conditions, index);
    
    std::vector<Object*> result;

    int stepResult = sqlite3_step(statement);
    int columnCount = sqlite3_column_count(statement);
    while (stepResult == SQLITE_ROW)
    {
        std::map<std::string, Datatype> row = dbObject.toMap();
        for (int i = 0; i < columnCount; ++i)
        {
            const std::string columnName = sqlite3_column_name(statement, i);
            const std::type_info& attrType = row[columnName].type();
            if (attrType == typeid(std::int64_t)) {
                row[columnName] = sqlite3_column_int64(statement, i);
            }
            if (attrType == typeid(double))
            {
                row[columnName] = sqlite3_column_double(statement, i);
            }
            if (attrType == typeid(std::string))
            {
                row[columnName] = std::string((char*)sqlite3_column_text(statement, i));
            }
        }
        result.push_back(dbObject.fromMap(row));
        
        stepResult = sqlite3_step(statement);
    }
    
    finalizeStatement(statement, "Error reading from database.");
    
    return result;
}

sqlite3_stmt* Handle::prepareStatement(const std::string& query) const
{
    sqlite3_stmt* statement;
    const int result = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (result != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing statement. SQLite3 error "
                                 + std::to_string(result) + ": "
                                 + sqlite3_errmsg(db));
    }
    
    return statement;
}

void Handle::bindStatementColumns(sqlite3_stmt* statement,
                                  const Object& dbObject,
                                  const std::vector<std::string>& columns,
                                  int& index, const bool isInsert) const
{
    std::map<std::string, Datatype> mMap = dbObject.toMap();
    
    for (auto it = columns.cbegin(); it != columns.cend(); ++it)
    {
        int result = SQLITE_OK;
        
        if (isInsert && dbObject.isAutoGeneratedKey()
            && dbObject.keys().count(*it))
        {
            result = sqlite3_bind_null(statement, index);
        }
        else
        {
            const Datatype columnValue = mMap[*it];
            const std::type_info& attrType = columnValue.type();
            if (attrType == typeid(std::int64_t))
            {
                result = sqlite3_bind_int64(statement, index,
                                            columnValue.cast<std::int64_t>());
            }
            if (attrType == typeid(double))
            {
                result = sqlite3_bind_double(statement, index,
                                             columnValue.cast<double>());
            }
            if (attrType == typeid(std::string))
            {
                result = sqlite3_bind_text(statement, index,
                                           columnValue.cast<std::string>().c_str(),
                                           -1, SQLITE_TRANSIENT);
            }
        }
        
        if (result != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            throw std::runtime_error("Error binding statement. SQLite3 error "
                                     + std::to_string(result) + ": "
                                     + sqlite3_errmsg(db));
        }
        
        ++index;
    }
}

void Handle::bindStatementConditions(sqlite3_stmt* statement,
                                     const std::vector<Condition>& conditions,
                                     int& index) const
{
    for (auto it = conditions.cbegin(); it != conditions.cend(); ++it)
    {
        int result = SQLITE_OK;
        
        const Datatype columnValue = it->value;
        const std::type_info& attrType = columnValue.type();
        if (attrType == typeid(std::int64_t))
        {
            result = sqlite3_bind_int64(statement, index,
                                        columnValue.cast<std::int64_t>());
        }
        if (attrType == typeid(double))
        {
            result = sqlite3_bind_double(statement, index,
                                         columnValue.cast<double>());
        }
        if (attrType == typeid(std::string))
        {
            result = sqlite3_bind_text(statement, index,
                                       columnValue.cast<std::string>().c_str(),
                                       -1, SQLITE_TRANSIENT);
        }
        if (attrType == typeid(std::vector<std::int64_t>))
        {
            const auto& in = columnValue.cast<std::vector<std::int64_t>>();
            for (auto itIn = in.cbegin(); itIn != in.cend(); ++itIn)
            {
                result = sqlite3_bind_int64(statement, index, *itIn);
                if (result != SQLITE_OK)
                {
                    sqlite3_finalize(statement);
                    throw std::runtime_error("Error binding statement. SQLite3 error "
                                             + std::to_string(result) + ": "
                                             + std::string(sqlite3_errmsg(db)));
                }
                ++index;
            }
            --index;
        }
        if (attrType == typeid(std::vector<std::string>))
        {
            const auto& in = columnValue.cast<std::vector<std::string>>();
            for (auto itIn = in.cbegin(); itIn != in.cend(); ++itIn)
            {
                result = sqlite3_bind_text(statement, index, (*itIn).c_str(),
                                           -1, SQLITE_TRANSIENT);
                if (result != SQLITE_OK)
                {
                    sqlite3_finalize(statement);
                    throw std::runtime_error("Error binding statement. SQLite3 error "
                                             + std::to_string(result) + ": "
                                             + std::string(sqlite3_errmsg(db)));
                }
                ++index;
            }
            --index;
        }
        
        if (result != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            throw std::runtime_error("Error binding statement. SQLite3 error "
                                     + std::to_string(result) + ": "
                                     + sqlite3_errmsg(db));
        }
        
        ++index;
    }
}

void Handle::finalizeStatement(sqlite3_stmt *statement,
                               const std::string& errorMessage) const
{
    int result = sqlite3_finalize(statement);
    if (result != SQLITE_OK)
    {
        throw std::runtime_error(errorMessage + " SQLite3 error "
                                 + std::to_string(result) + ": "
                                 + sqlite3_errmsg(db));
    }
}

void Handle::openDB(const std::string fileName)
{
    int result = sqlite3_open(fileName.c_str(), &db);
    if (result != SQLITE_OK) {
        closeDB();
        throw std::runtime_error("Error opening database. SQLite3 error "
                                 + std::to_string(result) + ": "
                                 + sqlite3_errmsg(db));
    }
}

void Handle::closeDB()
{
    int result = sqlite3_close(db);
    if (result != SQLITE_OK)
    {
        throw std::runtime_error("Error closing database. SQLite3 error "
                                 + std::to_string(result) + ": "
                                 + sqlite3_errmsg(db));
    }
}

std::string Handle::generateWhereClauseFromConditions(const std::vector<Condition>& conditions)
{
    if (conditions.empty())
    {
        return "";
    }
    
    std::string result = " WHERE ";
    for (auto it = conditions.cbegin(); it != conditions.cend(); it++)
    {
        const std::string op = opStr(it->op);
        if (op == "IN")
        {
            result += it->field + " " + op + " (";
            const std::type_info& attrType = it->value.type();
            if (attrType == typeid(std::vector<std::int64_t>))
            {
                std::size_t size = it->value.cast<std::vector<std::int64_t>>().size();
                for (std::size_t i = 0; i < size; ++i)
                {
                    result += "?,";
                }
            }
            else
            {
                std::size_t size = it->value.cast<std::vector<std::string>>().size();
                for (std::size_t i = 0; i < size; ++i)
                {
                    result += "?,";
                }
            }
            result = result.substr(0, result.size() - 1) + ") AND ";
        }
        else
        {
            result += it->field + " " + op + " ? AND ";
        }
    }
    result  = result.substr(0, result.size() - 5);
    return result;
}

std::string Handle::generateWhereClauseFromKeys(const std::vector<std::string>& keys)
{
    std::string result = " WHERE ";
    for (auto it = keys.cbegin(); it != keys.cend(); ++it)
    {
        result += *it + " = ? AND ";
    }
    
    return result;
}
